/**
 ******************************************************************************
 *
 * @file       frskyhub.c
 * @author     Anselm Kruis 2013.
 * @brief      Emulate a FrSky telemetrie hub.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input object: ExampleSettings
 * Output object: -
 *
 * This module will periodically update the value of the ExampleObject object.
 * The module settings can configure how the ExampleObject is manipulated.
 *
 * The module executes in its own thread in this example.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 */

#include "openpilot.h"
#include "modulesettings.h"

#include <stdbool.h>


// Private constants
#define CTASTR2(pre,post) pre ## post
#define CTASTR(pre,post) CTASTR2(pre,post)
#define STATIC_ASSERT(cond,msg) \
    typedef struct { int CTASTR(static_assertion_failed_,msg) : !!(cond); } \
        CTASTR(static_assertion_failed_,__COUNTER__)


#if defined(PIOS_FRSKYHUB_STACK_SIZE)
#define STACK_SIZE_BYTES PIOS_FRSKYHUB_STACK_SIZE
#else
#define STACK_SIZE_BYTES configMINIMAL_STACK_SIZE
#endif

#define TASK_PRIORITY                   (tskIDLE_PRIORITY + 1)

#define FRSKYHUB_BUF_LEN 10

#define PROTOCOL_HEADER       0x5E

// Data Ids  (bp = before decimal point; af = after decimal point)
// Official data IDs
#define ID_GPS_ALTIDUTE_BP    0x01
#define ID_GPS_ALTIDUTE_AP    0x09
#define ID_TEMPRATURE1        0x02
#define ID_RPM                0x03
#define ID_FUEL_LEVEL         0x04
#define ID_TEMPRATURE2        0x05
#define ID_VOLT               0x06
#define ID_ALTITUDE_BP        0x10
#define ID_ALTITUDE_AP        0x21
#define ID_GPS_SPEED_BP       0x11
#define ID_GPS_SPEED_AP       0x19
#define ID_LONGITUDE_BP       0x12
#define ID_LONGITUDE_AP       0x1A
#define ID_E_W                0x22
#define ID_LATITUDE_BP        0x13
#define ID_LATITUDE_AP        0x1B
#define ID_N_S                0x23
#define ID_COURSE_BP          0x14
#define ID_COURSE_AP          0x1C
#define ID_DATE_MONTH         0x15
#define ID_YEAR               0x16
#define ID_HOUR_MINUTE        0x17
#define ID_SECOND             0x18
#define ID_ACC_X              0x24
#define ID_ACC_Y              0x25
#define ID_ACC_Z              0x26
#define ID_VOLTAGE_AMP_BP     0x3A
#define ID_VOLTAGE_AMP_AP     0x3B
#define ID_CURRENT            0x28
// User defined data IDs
#define ID_GYRO_X             0x40
#define ID_GYRO_Y             0x41
#define ID_GYRO_Z             0x42

#define ID_DEBUG1             0x44
#define ID_DEBUG2             0x45


#define OUT_QUEUE_SIZE		8

// Private types

typedef uint8_t (*GetDataFunc)(portTickType); 

typedef struct {
	const GetDataFunc getData;
	const uint32_t    rateMs;
} Spec_t;
 

// Private variables
static bool module_enabled = false;
static xTaskHandle taskHandle;
static uint32_t usart_port;
static uint8_t * com_buf;

static uint8_t out_queue_id[OUT_QUEUE_SIZE];
static uint16_t out_queue_data[OUT_QUEUE_SIZE];


// Private functions
static void frSkyHubTask(void *parameters);
static void updateSettings();

// from sensors.c
extern uint8_t batteryCellCount;

#include "baroaltitude.h"
static uint8_t getAltitude(portTickType tick_count)
{
	STATIC_ASSERT(OUT_QUEUE_SIZE>=2, out_queue_size);
	BaroAltitudeData baroAltitude;
	if (BaroAltitudeGet(&baroAltitude))
		return 0;
		
    out_queue_id[0] = ID_ALTITUDE_AP;
    out_queue_id[1] = ID_ALTITUDE_BP;
    out_queue_data[0] = ((int32_t)(baroAltitude.Altitude*100)) % 100;
    out_queue_data[1] = baroAltitude.Altitude;
	return 2;
}


#include "gpsposition.h"
#include "systemalarms.h"
#include "flightstatus.h"
static uint8_t getStatus(portTickType tick_count)
{
	STATIC_ASSERT(OUT_QUEUE_SIZE>=1, out_queue_size);
	GPSPositionData gpsPosition;
	FlightStatusData flightStatus;
	if (FlightStatusGet(&flightStatus))
		return 0;
	if (GPSPositionGet(&gpsPosition))
		return 0;

	out_queue_id[0] = ID_FUEL_LEVEL;
	gpsPosition.Satellites -= 3;
	if (gpsPosition.Status != GPSPOSITION_STATUS_FIX3D)
		gpsPosition.Satellites = 0;
	if (gpsPosition.Satellites > 9)
		gpsPosition.Satellites = 9;
	out_queue_data[0] = gpsPosition.Satellites + 10 * flightStatus.FlightMode +
						flightStatus.Armed * 100 + flightStatus.ControlSource * 1000;
	return 1;
}

#include "gpsposition.h"
static uint8_t getPosition(portTickType tick_count)
{
	STATIC_ASSERT(OUT_QUEUE_SIZE>=6, out_queue_size);
	GPSPositionData gpsPosition;
	int32_t degrees;
	
	if (GPSPositionGet(&gpsPosition))
		return 0;

	if (gpsPosition.Status != GPSPOSITION_STATUS_FIX2D && gpsPosition.Status != GPSPOSITION_STATUS_FIX3D)
		/* no pos. don't send to avoid overriding the last position */
		return 0;
	
	out_queue_id[0] = ID_E_W;
	out_queue_id[1] = ID_LONGITUDE_AP;
	out_queue_id[2] = ID_LONGITUDE_BP;
	out_queue_id[3] = ID_N_S;
	out_queue_id[4] = ID_LATITUDE_AP;
	out_queue_id[5] = ID_LATITUDE_BP;

	if (gpsPosition.Longitude < 0) {
		out_queue_data[0] = 'W';
		gpsPosition.Longitude = -gpsPosition.Longitude;
	} else {
		out_queue_data[0] = 'E';
	}
	degrees = gpsPosition.Longitude / 10000000;
	gpsPosition.Longitude = (gpsPosition.Longitude % 10000000) * 6; /* result is in min * 10e-6 */
	out_queue_data[1] = (gpsPosition.Longitude % 1000000) / 100;
	out_queue_data[2] = 100 * degrees + gpsPosition.Longitude / 1000000;
	
	if (gpsPosition.Latitude  < 0) {
		out_queue_data[3] = 'S';
		gpsPosition.Latitude = -gpsPosition.Latitude;
	} else {
		out_queue_data[3] = 'N';
	}
	degrees = gpsPosition.Latitude / 10000000;
	gpsPosition.Latitude = (gpsPosition.Latitude % 10000000) * 6; /* result is in min * 10e-6 */
	out_queue_data[4] = (gpsPosition.Latitude % 1000000) / 100;
	out_queue_data[5] = 100 * degrees + gpsPosition.Latitude / 1000000;

	return 6;
}

#include "gpstime.h"
static uint8_t getGpsTime(portTickType tick_count)
{
	STATIC_ASSERT(OUT_QUEUE_SIZE>=4, out_queue_size);
	GPSTimeData gpsTimeData;
	if (GPSTimeGet(&gpsTimeData))
		return 0;
	
	out_queue_id[0] = ID_SECOND;
	out_queue_id[1] = ID_HOUR_MINUTE;
	out_queue_id[2] = ID_YEAR;
	out_queue_id[3] = ID_DATE_MONTH;

	if (gpsTimeData.Second || gpsTimeData.Minute || gpsTimeData.Hour ||
	    gpsTimeData.Day || gpsTimeData.Month || gpsTimeData.Year) {
		out_queue_data[0] = gpsTimeData.Second;
		out_queue_data[1] = gpsTimeData.Hour + (gpsTimeData.Minute << 8);
		out_queue_data[2] = gpsTimeData.Year % 100;
		out_queue_data[3] = gpsTimeData.Day + (gpsTimeData.Month << 8);
	} else {
		uint32_t t = TICKS2MS(tick_count);
		uint32_t x;
		t /= 1000;
		out_queue_data[0] = t % 60; t /= 60;
		x = t % 60; t /= 60;
		out_queue_data[1] = t % 24 + (x << 8); t /= 24;
		out_queue_data[2] = tick_count >> 16;
		out_queue_data[3] = tick_count;
	}
	
	return 4;
}

#include "attitudeactual.h"
static uint8_t getAttitudeYaw(portTickType tick_count)
{
	STATIC_ASSERT(OUT_QUEUE_SIZE>=2, out_queue_size);
	AttitudeActualData attitudeActualData;
	if (AttitudeActualGet(&attitudeActualData))
		return 0;
	
#   if 0
	/* more appropriate, but not supported by er9x frsky mode */
	out_queue_id[0] = ID_COURSE_AP;
	out_queue_id[1] = ID_COURSE_BP;
#else
	out_queue_id[0] = ID_GPS_SPEED_AP;
	out_queue_id[1] = ID_GPS_SPEED_BP;
#endif

	while (attitudeActualData.Yaw < 0)
		attitudeActualData.Yaw += 360;
	while (attitudeActualData.Yaw > 360)
		attitudeActualData.Yaw -= 360;
		
	out_queue_data[1] = attitudeActualData.Yaw;
	out_queue_data[0] = (attitudeActualData.Yaw - out_queue_data[1]) * 100;
	
	return 2;
}

#include "rollandpitchrotation.h"
static uint8_t getRollAndPitchRotation(portTickType tick_count)
{
	STATIC_ASSERT(OUT_QUEUE_SIZE>=2, out_queue_size);
	RollAndPitchRotationData rollAndPitchRotationData;
	if (RollAndPitchRotationGet(&rollAndPitchRotationData))
		return 0;
	
#   if 0
	/* more appropriate, but not supported by er9x frsky mode */
	out_queue_id[0] = ID_COURSE_AP;
	out_queue_id[1] = ID_COURSE_BP;
#else
	out_queue_id[0] = ID_GPS_SPEED_AP;
	out_queue_id[1] = ID_GPS_SPEED_BP;
#endif
	
	if (rollAndPitchRotationData.YawOffset >= 0) { 
		out_queue_data[1] = rollAndPitchRotationData.Rotation;
		out_queue_data[0] = (rollAndPitchRotationData.Rotation - out_queue_data[1]) * 100;
	} else {
		out_queue_data[1] = -1;
		out_queue_data[0] = 0;
	}
	
	return 2;
}


static const Spec_t specs[] = {
	{ getGpsTime, 2200 },
	{ getStatus, 10},
	{ getAltitude, 500 },
	{ getAttitudeYaw, 0 },
	{ getRollAndPitchRotation, 500 },
	{ getPosition, 900 },
};

static const size_t specs_size = sizeof(specs) / sizeof(specs[0]);
static portTickType due_ticks[sizeof(specs) / sizeof(specs[0])];

static uint8_t fillOutQueue(portTickType tick_count)
{
	portTickType next_ticks;
	size_t i, next_index;
	uint8_t ret;
	
	next_ticks = portMAX_DELAY;
	next_index = 0;

	for (i=0; i<specs_size; i++) {
		if (due_ticks[i] > tick_count)
			continue;
		if (specs[i].rateMs && due_ticks[i] < next_ticks) {
			next_ticks = due_ticks[i];
			next_index = i;
		}
	}
	
	if (next_ticks == portMAX_DELAY) {
		/* no data to send */
		return 0;
	}
	
	/* update the due time */
	due_ticks[next_index] = tick_count + MS2TICKS(specs[next_index].rateMs);
	ret = specs[next_index].getData(tick_count);
	
#   if 0
	out_queue_id[ret] = ID_DEBUG2;
	out_queue_data[ret++] = due_ticks[next_index];
	out_queue_id[ret] = ID_DEBUG1;
	out_queue_data[ret++] = due_ticks[next_index] >> 16;
#   endif 
	
	return ret;
}

#if 0

static void sendAccel(void)
{
    int i;

    for (i = 0; i < 3; i++) {
        sendDataHead(ID_ACC_X + i);
        serialize16(((float)accSmooth[i] / acc_1G) * 1000);
    }
}


static void sendTemperature1(void)
{
    sendDataHead(ID_TEMPRATURE1);
    serialize16(telemTemperature1 / 10);
}


static void sendGPS(void)
{
    sendDataHead(ID_LATITUDE_BP);
    serialize16(abs(GPS_coord[LAT]) / 100000);
    sendDataHead(ID_LATITUDE_AP);
    serialize16((abs(GPS_coord[LAT]) / 10) % 10000);

    sendDataHead(ID_N_S);
    serialize16(GPS_coord[LAT] < 0 ? 'S' : 'N');

    sendDataHead(ID_LONGITUDE_BP);
    serialize16(abs(GPS_coord[LON]) / 100000);
    sendDataHead(ID_LONGITUDE_AP);
    serialize16((abs(GPS_coord[LON]) / 10) % 10000);
    sendDataHead(ID_E_W);
    serialize16(GPS_coord[LON] < 0 ? 'W' : 'E');
}

/*
 * Send voltage via ID_VOLT
 *
 * NOTE: This sends voltage divided by batteryCellCount. To get the real
 * battery voltage, you need to multiply the value by batteryCellCount.
 */
static void sendVoltage(void)
{
    static uint16_t currentCell = 0;
    uint16_t cellNumber;
    uint32_t cellVoltage;
    uint16_t payload;

    /*
     * Note: Fuck the pdf. Format for Voltage Data for single cells is like this:
     *
     *  llll llll cccc hhhh
     *  l: Low voltage bits
     *  h: High voltage bits
     *  c: Cell number (starting at 0)
     */
    cellVoltage = vbat / batteryCellCount;

    // Map to 12 bit range
    cellVoltage = (cellVoltage * 2100) / 42;

    cellNumber = currentCell % batteryCellCount;

    // Cell number is at bit 9-12
    payload = (cellNumber << 4);

    // Lower voltage bits are at bit 0-8
    payload |= ((cellVoltage & 0x0ff) << 8);

    // Higher voltage bits are at bits 13-15
    payload |= ((cellVoltage & 0xf00) >> 8);

    sendDataHead(ID_VOLT);
    serialize16(payload);

    currentCell++;
    currentCell %= batteryCellCount;
}

/*
 * Send voltage with ID_VOLTAGE_AMP
 */
static void sendVoltageAmp(void)
{
    uint16_t voltage = (vbat * 110) / 21;

    sendDataHead(ID_VOLTAGE_AMP_BP);
    serialize16(voltage / 100);
    sendDataHead(ID_VOLTAGE_AMP_AP);
    serialize16(((voltage % 100) + 5) / 10);
}

static void sendHeading(void)
{
    sendDataHead(ID_COURSE_BP);
    serialize16(heading);
    sendDataHead(ID_COURSE_AP);
    serialize16(0);
}

#endif

static uint8_t hubEncode(uint8_t * buf, uint8_t dataId, uint16_t data) {
	uint8_t i, d, count=4;
	*buf++ = PROTOCOL_HEADER;
	*buf++ = dataId;
	for (i=0; i<2; i++) {
		d=data;
		switch(d) {
			case 0x5d:
			case 0x5e:
				*buf++ = 0x5d;
				*buf++ = d - 0x20;
				count++;
				break;
			default:
				*buf++ = d;
		}
		data >>= 8;
	}
	return count;
}


/**
 * Initialise the module
 * \return -1 if initialisation failed
 * \return 0 on success
 */
static int32_t frSkyHubStart(void)
{
	if (module_enabled) {
		// Start tasks
		xTaskCreate(frSkyHubTask, (signed char *)"FrSkyHub", STACK_SIZE_BYTES, NULL, TASK_PRIORITY, &taskHandle);
		TaskMonitorAdd(TASKINFO_RUNNING_FRSKYHUB, taskHandle);
		return 0;
	}

	return -1;
}

/**
 * Initialise the module
 * \return -1 if initialisation failed
 * \return 0 on success
 */
static int32_t frSkyHubInitialize(void)
{
	// TODO: Get from settings object
	usart_port = PIOS_COM_FRSKYHUB;

	/* Only run the module if we have a selected USART port */
	if (!usart_port) {
		module_enabled = false;
		return 0;
	}

#ifdef MODULE_FrSkyHub_BUILTIN
	module_enabled = true;
#else
	uint8_t module_state[MODULESETTINGS_ADMINSTATE_NUMELEM];
	ModuleSettingsAdminStateGet(module_state);
	if (module_state[MODULESETTINGS_ADMINSTATE_FRSKYHUB] == MODULESETTINGS_ADMINSTATE_ENABLED) {
		module_enabled = true;
	} else {
		module_enabled = false;
	}
#endif

	if (module_enabled) {
		com_buf = pvPortMalloc(FRSKYHUB_BUF_LEN);
		PIOS_Assert(com_buf);

		updateSettings();
	}

	return 0;
}
MODULE_INITCALL(frSkyHubInitialize, frSkyHubStart)

static void updateSettings()
{
	if (usart_port) {
		PIOS_COM_ChangeBaud(usart_port, 9600);
	}
}

/**
 * Main task. It does not return.
 */
static void frSkyHubTask(void *parameters)
{
	portTickType lastSysTime;
	volatile uint32_t tx_errors = 0;
	uint32_t tx_bytes=0;
	uint32_t out_queue_len=0;
	//int counter=0;

	// Main task loop
	lastSysTime = xTaskGetTickCount();
	while (1) {
		int32_t rc;
		
		if (0 == out_queue_len) {
			out_queue_len = fillOutQueue(xTaskGetTickCount());
		}
		if (0 != out_queue_len) {
			out_queue_len--;
			
			// Fill the buffer. 
			tx_bytes = hubEncode(com_buf, out_queue_id[out_queue_len], out_queue_data[out_queue_len]);
			// At most 6 bytes per frame,
			// because the a FrSky user frame contains at most 6 bytes
			// user data.
			PIOS_Assert(tx_bytes <= 6);
			
			// Send
			rc = PIOS_COM_SendBufferNonBlocking(usart_port, com_buf, tx_bytes);
			if (-2 == rc) {
				// no space in device tx buffer, retry later
				out_queue_len++;
				tx_bytes = 0;
			} else if (tx_bytes != rc) {
				/* Error on transmit */
				tx_errors++;
			}
		}
		
		// Since this module executes at fixed time intervals, we need to
		// block the task until it is time for the next update.
		// The settings field is in ms, to convert to RTOS ticks we need
		// to use the MS2TICKS macro.
		
		// From FrSky document "Two-way system protocol": 
		//   "Pure data throughput should NOT exceed 1200bps, 
		//    MAY experience BYTE DISCARD."
		// Actually the limit is at 6 Bytes every 36ms, that' about 1666bps.
		// FrSky telemetrie sends a donlink frame with 6 byte user data every 36ms.
		//
		// Because the UART operates with 9600bps we need to pause
		// 8ms for each transmitted byte.
		// 
		tx_bytes *= 8;
		if (tx_bytes < 36)
			tx_bytes = 36; // limit of the transmitter
		vTaskDelayUntil(&lastSysTime, MS2TICKS(tx_bytes));
	}
}
